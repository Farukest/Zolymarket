const { createFhevmInstance } = require('fhevmjs');
const { ethers } = require('ethers');
const { logger } = require('../utils/logger');

class FHEVMService {
  constructor() {
    this.fhevmInstance = null;
    this.provider = null;
    this.initialized = false;
    this.publicKeys = new Map(); // Cache for public keys
  }

  // Initialize FHEVM service
  async initialize() {
    try {
      // Setup provider
      this.provider = new ethers.JsonRpcProvider(
        process.env.SEPOLIA_RPC_URL,
      );

      // Create FHEVM instance
      this.fhevmInstance = await createFhevmInstance({
        provider: this.provider.provider || this.provider,
        gatewayUrl: process.env.GATEWAY_URL || 'https://gateway.sepolia.zama.ai/',
        aclAddress: process.env.ACL_ADDRESS,
        acoAddress: process.env.ACO_ADDRESS,
      });

      this.initialized = true;
      logger.info('FHEVM service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize FHEVM service:', error);
      throw error;
    }
  }

  // Ensure service is initialized
  ensureInitialized() {
    if (!this.initialized) {
      throw new Error('FHEVM service not initialized');
    }
  }

  // Encrypt a 64-bit unsigned integer
  async encrypt64(value, contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const input = this.fhevmInstance.createEncryptedInput(contractAddress, userAddress);
      input.add64(value);
      const encrypted = input.encrypt();

      return {
        handles: encrypted.handles,
        inputProof: encrypted.inputProof,
      };
    } catch (error) {
      logger.error('Failed to encrypt 64-bit value:', error);
      throw error;
    }
  }

  // Encrypt a boolean value
  async encryptBool(value, contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const input = this.fhevmInstance.createEncryptedInput(contractAddress, userAddress);
      input.addBool(value);
      const encrypted = input.encrypt();

      return {
        handles: encrypted.handles,
        inputProof: encrypted.inputProof,
      };
    } catch (error) {
      logger.error('Failed to encrypt boolean value:', error);
      throw error;
    }
  }

  // Encrypt an address
  async encryptAddress(address, contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const input = this.fhevmInstance.createEncryptedInput(contractAddress, userAddress);
      input.addAddress(address);
      const encrypted = input.encrypt();

      return {
        handles: encrypted.handles,
        inputProof: encrypted.inputProof,
      };
    } catch (error) {
      logger.error('Failed to encrypt address:', error);
      throw error;
    }
  }

  // Generate public key for a contract
  async generatePublicKey(contractAddress) {
    this.ensureInitialized();

    try {
      // Check cache first
      if (this.publicKeys.has(contractAddress)) {
        return this.publicKeys.get(contractAddress);
      }

      const publicKey = await this.fhevmInstance.generatePublicKey(contractAddress);

      // Cache the public key
      this.publicKeys.set(contractAddress, publicKey);

      return publicKey;
    } catch (error) {
      logger.error('Failed to generate public key:', error);
      throw error;
    }
  }

  // Reencrypt a value for viewing
  async reencrypt(encryptedValue, publicKey, contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const reencrypted = await this.fhevmInstance.reencrypt(
        encryptedValue,
        publicKey,
        contractAddress,
        userAddress,
      );

      return reencrypted;
    } catch (error) {
      logger.error('Failed to reencrypt value:', error);
      throw error;
    }
  }

  // Request decryption of an encrypted value
  async requestDecryption(encryptedValues, callbackSelector, contractAddress) {
    this.ensureInitialized();

    try {
      // Convert encrypted values to bytes32 format
      const bytes32Values = encryptedValues.map((value) => {
        if (typeof value === 'string') {
          return value;
        }
        // Convert to bytes32 if needed
        return ethers.zeroPadValue(ethers.toBeHex(value), 32);
      });

      // This would typically be called from a smart contract
      // For demonstration, we'll just log the request
      logger.info('Decryption requested:', {
        values: bytes32Values,
        callback: callbackSelector,
        contract: contractAddress,
      });

      // Return request ID (would be generated by the oracle)
      return ethers.keccak256(
        ethers.solidityPacked(
          ['bytes32[]', 'bytes4', 'address', 'uint256'],
          [bytes32Values, callbackSelector, contractAddress, Date.now()],
        ),
      );
    } catch (error) {
      logger.error('Failed to request decryption:', error);
      throw error;
    }
  }

  // Validate encrypted input
  validateEncryptedInput(encryptedData) {
    if (!encryptedData) {
      return false;
    }

    if (!encryptedData.handles || !Array.isArray(encryptedData.handles)) {
      return false;
    }

    if (!encryptedData.inputProof || typeof encryptedData.inputProof !== 'string') {
      return false;
    }

    return encryptedData.handles.length > 0;
  }

  // Create multiple encrypted inputs
  async encryptMultiple(values, contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const input = this.fhevmInstance.createEncryptedInput(contractAddress, userAddress);

      // Add values based on their types
      for (const [key, value] of Object.entries(values)) {
        if (typeof value === 'number') {
          input.add64(value);
        } else if (typeof value === 'boolean') {
          input.addBool(value);
        } else if (typeof value === 'string' && value.startsWith('0x')) {
          input.addAddress(value);
        } else {
          throw new Error(`Unsupported value type for key: ${key}`);
        }
      }

      const encrypted = input.encrypt();

      return {
        handles: encrypted.handles,
        inputProof: encrypted.inputProof,
      };
    } catch (error) {
      logger.error('Failed to encrypt multiple values:', error);
      throw error;
    }
  }

  // Check if user has permission to decrypt
  async hasDecryptPermission(encryptedValue, userAddress, contractAddress) {
    this.ensureInitialized();

    try {
      const hasPermission = await this.fhevmInstance.hasPermission(
        encryptedValue,
        userAddress,
        contractAddress,
      );

      return hasPermission;
    } catch (error) {
      logger.error('Failed to check decrypt permission:', error);
      return false;
    }
  }

  // Generate permission for decryption
  async generatePermission(contractAddress, userAddress) {
    this.ensureInitialized();

    try {
      const permission = await this.fhevmInstance.generatePermission(
        contractAddress,
        userAddress,
      );

      return permission;
    } catch (error) {
      logger.error('Failed to generate decryption permission:', error);
      throw error;
    }
  }

  // Utility: Convert amount to USDC format (6 decimals)
  amountToUSDC(amount) {
    return Math.floor(amount * 1e6);
  }

  // Utility: Convert USDC format to amount
  usdcToAmount(usdcValue) {
    return usdcValue / 1e6;
  }

  // Get service status
  getStatus() {
    return {
      initialized: this.initialized,
      gatewayUrl: process.env.GATEWAY_URL,
      aclAddress: process.env.ACL_ADDRESS,
      acoAddress: process.env.ACO_ADDRESS,
      publicKeysCached: this.publicKeys.size,
    };
  }

  // Clear public key cache
  clearPublicKeyCache() {
    this.publicKeys.clear();
    logger.info('Public key cache cleared');
  }

  // Get cached public keys
  getCachedPublicKeys() {
    return Array.from(this.publicKeys.entries()).map(([address, publicKey]) => ({
      contractAddress: address,
      publicKey: `${publicKey.substring(0, 20)}...`, // Truncate for logging
    }));
  }
}

// Create singleton instance
const fhevmService = new FHEVMService();

module.exports = { fhevmService };
